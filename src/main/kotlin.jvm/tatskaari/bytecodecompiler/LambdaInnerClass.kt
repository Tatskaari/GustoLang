package tatskaari.bytecodecompiler


import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes
import org.objectweb.asm.Type
import tatskaari.parsing.TypeChecking.TypedStatement
import java.util.*

class LambdaInnerClass(val function: TypedStatement.FunctionDeclaration, val parentScope: Env, classWriter: ClassWriter){
  val undeclaredVariables : LinkedList<String>
  val lambdaType : Type
  init {
    // figure out what variables the lambda uses from the parent scope
    val scopeVisitor = ScopeStatementVisitor()
    function.accept(scopeVisitor)
    undeclaredVariables = scopeVisitor.undeclaredVariables
    lambdaType = JVMTypeHelper.getLambdaType(function.functionType, parentScope, undeclaredVariables)

    // construct the lambda local variables
    val lambdaEnv = Env()

    // add the parameters generated by the compiler for "undeclared" variables declared outside the function in the parent scope
    undeclaredVariables.forEachIndexed{index, name ->
      val type = parentScope.getValue(name).type
      lambdaEnv.put(name, Variable(index, type))
    }

    // add the parameters that were actually part of the Gusto function
    function.functionType.params
      .zip(function.statement.function.params)
      .forEachIndexed{ idx, (gustoType, identifier) ->
        val paramType = Type.getType(JVMTypeHelper.getTypeDesc(gustoType, true))
        lambdaEnv.put(identifier.name, Variable(idx + undeclaredVariables.size, paramType))
      }

    // compile the body of the statement into the lambda
    val lambdaStatementVisitor = JVMTypedStatementVisitor(classWriter, lambdaEnv, "lambda$${function.statement.identifier.name}", lambdaType.descriptor, Opcodes.ACC_PRIVATE + Opcodes.ACC_STATIC + Opcodes.ACC_SYNTHETIC)
    function.body.accept(lambdaStatementVisitor)
    lambdaStatementVisitor.close()
  }

  fun getJVMType(): Type{
    return lambdaType
  }
}